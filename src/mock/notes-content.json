{
  "execution-context": "\n      <h2>1. 실행 컨텍스트와 콜스택</h2>\n      <p><strong>Context = 문맥</strong> : 글이나 문장에 표현된 의미의 앞뒤 연결을 의미합니다. 자바스크립트에서 실행 컨텍스트는 자바스크립트 실행의 앞뒤를 연결해주는 중추적인 역할을 합니다.</p>\n      \n      <blockquote>\n        <strong>실행 컨텍스트(Execution Context)</strong><br/>\n        자바스크립트의 동작 원리를 담고 있는 핵심 개념입니다. 실행하려는 코드에 제공할 <strong>환경 정보</strong>들을 모아놓는 객체이며, 생성된 컨텍스트는 자바스크립트 엔진의 <strong>Call Stack</strong>에 쌓여 관리됩니다.\n      </blockquote>\n\n      <h3>실행 컨텍스트의 역할</h3>\n      <p>코드 실행 과정에서 다음과 같은 핵심적인 관리 기능을 수행합니다.</p>\n      <ul>\n        <li><strong>식별자 관리:</strong> 선언된 모든 식별자(변수, 함수 등)를 스코프별로 등록하고 관리합니다.</li>\n        <li><strong>스코프 체인:</strong> 상위 스코프로 이동하며 식별자를 검색할 수 있는 경로를 제공합니다.</li>\n        <li><strong>실행 순서 관리:</strong> 함수 호출 등으로 인한 실행 흐름의 변경과 복귀를 관리합니다.</li>\n      </ul>\n\n      <h3>구성 요소</h3>\n      <ul>\n        <li><strong>렉시컬 환경 (Lexical Environment):</strong> 식별자와 스코프를 관리합니다.</li>\n        <li><strong>실행 컨텍스트 스택 (Execution Context Stack):</strong> 코드의 실행 순서를 관리하는 콜스택입니다.</li>\n      </ul>\n\n      <h2>2. 소스코드의 평가와 실행</h2>\n      <p>자바스크립트 엔진은 소스코드를 '평가'와 '실행'의 2단계로 나누어 처리합니다.</p>\n      \n      <h4>1단계: 소스코드 평가 (Evaluation Stage)</h4>\n      <ul>\n        <li>실행 컨텍스트를 생성합니다.</li>\n        <li>변수, 함수 등의 선언문만 먼저 실행하여 식별자를 스코프(Record)에 등록합니다. (호이스팅 발생)</li>\n      </ul>\n\n      <h4>2단계: 소스코드 실행 (Execution Stage)</h4>\n      <ul>\n        <li>선언문을 제외한 소스코드가 순차적으로 실행되는 런타임이 시작됩니다.</li>\n        <li>필요한 정보는 스코프에서 검색하고, 실행 결과(변수 값 변경 등)는 다시 스코프에 등록합니다.</li>\n      </ul>\n\n      <pre><code>// 예시: 변수 선언과 할당 프로세스\nvar x; // [평가] 스코프에 x 등록, undefined 초기화\nx = 1; // [실행] 스코프에서 x 확인 후 1 할당</code></pre>\n\n      <h3>4가지 타입의 소스코드</h3>\n      <table style=\"width:100%; border-collapse: collapse; margin: 15px 0;\">\n        <thead>\n          <tr style=\"background-color: rgba(255,255,255,0.1);\">\n            <th style=\"border: 1px solid #555; padding: 10px;\">타입</th>\n            <th style=\"border: 1px solid #555; padding: 10px;\">설명</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td style=\"border: 1px solid #555; padding: 10px;\"><strong>전역 코드</strong></td>\n            <td style=\"border: 1px solid #555; padding: 10px;\">전역 스코프 생성. var 전역 변수와 함수 선언문을 전역 객체에 바인딩.</td>\n          </tr>\n          <tr>\n            <td style=\"border: 1px solid #555; padding: 10px;\"><strong>함수 코드</strong></td>\n            <td style=\"border: 1px solid #555; padding: 10px;\">지역 스코프 생성. 매개변수, arguments 객체 관리. 스코프 체인 연결.</td>\n          </tr>\n          <tr>\n            <td style=\"border: 1px solid #555; padding: 10px;\"><strong>eval 코드</strong></td>\n            <td style=\"border: 1px solid #555; padding: 10px;\">strict mode에서 독자적인 스코프 생성.</td>\n          </tr>\n          <tr>\n            <td style=\"border: 1px solid #555; padding: 10px;\"><strong>모듈 코드</strong></td>\n            <td style=\"border: 1px solid #555; padding: 10px;\">모듈별 독립적인 스코프 생성.</td>\n          </tr>\n        </tbody>\n      </table>\n\n      <h2>3. 실행 컨텍스트 콜스택 (동작 예시)</h2>\n      <p>콜스택은 LIFO(Last In, First Out) 구조로, 가장 최근에 추가된 컨텍스트가 활성화됩니다.</p>\n\n      <pre><code>// 콜스택 예제 코드\nvar temp = 'temp';\nfunction b() { console.log('hello im function b'); }\nfunction a() { b(); }\na();</code></pre>\n\n      <h4>콜스택 흐름 시각화:</h4>\n      <pre style=\"background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 5px;\">\n[ Step 1 ] Global Context 담김 (Stack: [Global])\n[ Step 2 ] a() 호출 -> a Context 담김 (Stack: [Global, a])\n[ Step 3 ] b() 호출 -> b Context 담김 (Stack: [Global, a, b])\n[ Step 4 ] b() 종료 -> b Context 제거 (Stack: [Global, a])\n[ Step 5 ] a() 종료 -> a Context 제거 (Stack: [Global])\n[ Step 6 ] 전역 중료 -> Global 제거 (Stack: [])\n      </pre>\n\n      <h2>4. Record와 호이스팅</h2>\n      <p><strong>Environment Record</strong>는 현재 컨텍스트 내부의 식별자 정보를 저장합니다.</p>\n\n      <h3>var vs let/const 호이스팅</h3>\n      <ul>\n        <li><strong>var:</strong> 평가 단계에서 <strong>선언과 초기화(undefined)</strong>가 동시에 발생합니다. 선언 전에도 에러 없이 참조 가능합니다.</li>\n        <li><strong>let/const:</strong> 평가 단계에서 <strong>선언</strong>만 이루어지고 초기화는 되지 않습니다. 선언문 전까지 <strong>TDZ(Temporal Dead Zone)</strong>가 형성되어 참조 시 에러가 발생합니다.</li>\n      </ul>\n\n      <pre><code>// 렉시컬 환경에서의 표현 (개념적 구조)\nExecutionContext = {\n  LexicalEnvironment: {\n    EnvironmentRecord: {\n       temp: &lt;value&gt;,   // 식별자 정보\n    },\n    OuterEnvironmentReference: &lt;outer&gt; // 상위 스코프 참조\n  }\n}</code></pre>\n\n      <h2>5. Outer와 스코프 체이닝</h2>\n      <p><strong>Outer Environment Reference</strong>는 외부 렉시컬 환경에 대한 참조로, 이를 통해 단방향 리스트 형태의 <strong>스코프 체인</strong>이 형성됩니다.</p>\n      \n      <ul>\n        <li><strong>식별자 결정(Identifier Resolution):</strong> 변수 요청 시 현재 Record에서 찾고, 없으면 Outer를 타고 상위로 이동하며 검색합니다.</li>\n        <li><strong>Shadowing:</strong> 하위 스코프에 동일 이름의 식별자가 있으면 상위 식별자가 가려지는 현상입니다.</li>\n        <li><strong>결과:</strong> 전역 컨텍스트까지 찾아도 없으면 Reference Error가 발생합니다.</li>\n      </ul>\n    ",
  "hoisting": "\n      <h2>1. 호이스팅이란?</h2>\n      <p><code>호이스팅(Hoisting)</code>은 인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 임포트의 선언문을 해당 범위의 <strong>맨 위로</strong> 끌어올리는 것처럼 보이는 현상을 뜻합니다.</p>\n      \n      <pre><code>console.log(str); // undefined\nvar str = \"Hello\";</code></pre>\n      <p>위 코드에서 변수 <code>str</code>이 선언되기 전임에도 에러 없이 <code>undefined</code>가 출력되는 것이 호이스팅의 대표적인 예입니다.</p>\n\n      <h2>2. 변수 호이스팅</h2>\n      \n      <h3>1) var</h3>\n      <p><code>var</code> 키워드는 선언 단계와 초기화 단계가 동시에 이루어집니다.</p>\n      <ul>\n        <li><strong>선언 단계:</strong> 변수를 실행 컨텍스트의 변수 객체에 등록합니다.</li>\n        <li><strong>초기화 단계:</strong> 메모리 공간을 확보하고 <code>undefined</code>로 초기화합니다.</li>\n        <li><strong>할당 단계:</strong> 코드의 할당문에 도달했을 때 실제 값을 할당합니다.</li>\n      </ul>\n\n      <h3>2) let / const</h3>\n      <p><code>let</code>과 <code>const</code>는 호이스팅이 발생하지만, 선언과 초기화가 분리되어 진행됩니다.</p>\n      <ul>\n        <li><strong>선언 단계:</strong> 실행 컨텍스트에 변수를 등록합니다.</li>\n        <li><strong>TDZ (Temporal Dead Zone):</strong> 선언과 초기화 사이의 구간입니다. 이 구간에서 변수 참조 시 <code>ReferenceError</code>가 발생합니다.</li>\n        <li><strong>초기화 단계:</strong> 코드의 선언문에 도달했을 때 메모리를 확보하고 초기화합니다.</li>\n      </ul>\n\n      <h4>ES5 vs ES6 호이스팅 비교 (시각화):</h4>\n      <pre style=\"background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 5px;\">\n[ ES5: var ]\n선언 + 초기화 (undefined) ----> 할당\n\n[ ES6: let/const ]\n선언 ----> ( TDZ 구간: 참조 불가 ) ----> 초기화 ----> 할당\n      </pre>\n\n      <h2>3. 함수 호이스팅</h2>\n      \n      <h3>1) 함수 선언문 (Function Declaration)</h3>\n      <p>런타임 이전에 함수 객체가 생성되고 식별자에 할당까지 완료됩니다. 따라서 선언문 이전에 호출이 가능합니다.</p>\n      <pre><code>func(); // \"Hello\"\nfunction func() { console.log(\"Hello\"); }</code></pre>\n\n      <h3>2) 함수 표현식 (Function Expression)</h3>\n      <p>변수에 함수를 할당하는 방식이므로 <strong>변수 호이스팅 규칙</strong>을 따릅니다.</p>\n      <pre><code>func(); // var 선언 시 TypeError / let 선언 시 ReferenceError\nvar func = function() { console.log(\"Hello\"); };</code></pre>\n      <ul>\n        <li><code>var</code> 사용 시: <code>undefined()</code>를 호출하는 꼴이 되어 <code>TypeError</code>가 발생합니다.</li>\n        <li><code>let/const</code> 사용 시: TDZ 구간에 있어 <code>ReferenceError</code>가 발생합니다.</li>\n      </ul>\n\n      <h2>4. 클래스 호이스팅</h2>\n      <p><code>class</code> 선언 역시 호이스팅되지만, <code>let</code>과 마찬가지로 초기화 전까지 참조할 수 없어 마치 호이스팅이 되지 않는 것처럼 동작합니다(ReferenceError).</p>\n      \n      <pre><code>console.log(Person); // ReferenceError\nclass Person {}</code></pre>\n    ",
  "this": "\n      <h2>1. 개요 및 정의</h2>\n      <p><code>this</code>는 자바스크립트 실행 컨텍스트의 핵심 구성 요소 중 하나입니다. 많은 개발자들이 혼란을 겪는 이유는 <code>this</code>가 선언 시점이 아닌 <strong>호출 시점에 동적으로 결정</strong>되기 때문입니다.</p>\n      \n      <h3>실행 컨텍스트와 ThisBinding</h3>\n      <p>함수가 호출되면 실행 컨텍스트가 생성되고, 그 내부의 <code>ThisBinding</code> 컴포넌트에 <code>this</code>가 가리킬 객체가 저장됩니다.</p>\n      <pre style=\"background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 5px;\">\nExecution Context = {\n  LexicalEnvironment: { ... },\n  VariableEnvironment: { ... },\n  ThisBinding: &lt;this가 가리키는 객체&gt;\n}\n      </pre>\n\n      <h2>2. 4가지 바인딩 규칙</h2>\n\n      <h3>1) 기본 바인딩 (Default Binding)</h3>\n      <p>일반 함수로 호출될 때 적용되는 규칙입니다.</p>\n      <ul>\n        <li>브라우저 환경: <code>window</code> 객체</li>\n        <li>Node.js 환경: <code>global</code> 객체</li>\n        <li><strong>Strict Mode:</strong> <code>undefined</code></li>\n      </ul>\n\n      <h3>2) 암시적 바인딩 (Implicit Binding)</h3>\n      <p>함수가 객체의 메서드로서 호출될 때 적용됩니다. 이때 <code>this</code>는 <strong>함수를 호출한 객체</strong>를 가리킵니다.</p>\n      <pre><code>const obj = {\n  name: 'Tummy',\n  sayName() { console.log(this.name); }\n};\nobj.sayName(); // \"Tummy\"</code></pre>\n\n      <h3>3) 명시적 바인딩 (Explicit Binding)</h3>\n      <p>메서드를 통해 사용자가 직접 <code>this</code>를 지정하는 방법입니다.</p>\n      <ul>\n        <li><code>call(thisArg, ...args)</code>: 즉시 실행하며 인자를 각각 전달합니다.</li>\n        <li><code>apply(thisArg, [argsArray])</code>: 즉시 실행하며 인자를 배열로 전달합니다.</li>\n        <li><code>bind(thisArg)</code>: <code>this</code>가 고정된 <strong>새로운 함수를 반환</strong>합니다.</li>\n      </ul>\n\n      <h3>4) new 바인딩 (new Binding)</h3>\n      <p>생성자 함수를 통해 새로운 인스턴스를 생성할 때, <code>this</code>는 <strong>새로 생성된 인스턴스</strong>를 가리킵니다.</p>\n\n      <h2>3. 화살표 함수 (Arrow Function)</h2>\n      <p>화살표 함수는 일반 함수와 <code>this</code> 바인딩 방식이 근본적으로 다릅니다.</p>\n      <ul>\n        <li>자신만의 <code>this</code>를 가지지 않습니다.</li>\n        <li><strong>Lexical this:</strong> 함수가 선언된 시점의 상위 스코프에 있는 <code>this</code>를 그대로 참조합니다.</li>\n        <li>명시적 바인딩 메서드로 <code>this</code>를 변경할 수 없습니다.</li>\n      </ul>\n\n      <h2>4. 이벤트 처리기에서의 this</h2>\n      <p><code>addEventListener</code>의 콜백으로 일반 함수를 사용하면, <code>this</code>는 <strong>이벤트를 발생시킨 DOM 요소</strong>를 가리킵니다. (브라우저가 그렇게 바인딩하여 호출해주기 때문입니다.)</p>\n      <pre><code>console.log(btn.name); // \"I am button\"</code></pre>\n    ",
  "scope-chain": "\n      <h2>1. 스코프(Scope)란?</h2>\n      <p>식별자는 자신이 선언된 위치에 따라 참조할 수 있는 유효한 범위를 가지게 되며, 이를 <strong>스코프</strong>라고 합니다.</p>\n      \n      <h3>1) 전역(Global) 스코프</h3>\n      <p>코드의 가장 바깥 영역으로, 어디서든 해당 변수나 함수에 접근할 수 있습니다.</p>\n\n      <h3>2) 지역(Local) 스코프</h3>\n      <p>특정 영역(함수 또는 블록) 내부에서만 유효한 범위입니다.</p>\n      <ul>\n        <li><strong>함수 스코프:</strong> 함수 내부에서 선언된 변수는 오직 함수 내부에서만 참조 가능합니다. (var, let, const 모두 해당)</li>\n        <li><strong>블록 스코프:</strong> <code>if</code>, <code>for</code>, <code>switch</code> 등 중괄호 <code>{}</code> 블록 내부에서만 유효합니다. (<code>let</code>, <code>const</code>만 해당)</li>\n      </ul>\n\n      <pre><code>// var vs let의 블록 스코프 차이\nif (true) {\n  var v = \"var\";\n  let l = \"let\";\n}\nconsole.log(v); // \"var\" (접근 가능)\nconsole.log(l); // ReferenceError (접근 불가)</code></pre>\n\n      <h2>2. 스코프 체인(Scope Chain)</h2>\n      <p>스코프가 계층적으로 연결되어 있는 것을 의미합니다. 변수를 참조할 때 자바스크립트 엔진은 다음과 같은 과정을 거칩니다.</p>\n      <ol>\n        <li>현재 실행 중인 컨텍스트의 스코프에서 변수를 찾습니다.</li>\n        <li>없다면 상위 스코프(Outer Environment Reference)로 이동하여 탐색을 반복합니다.</li>\n        <li>최상위인 전역 스코프까지 탐색했음에도 없다면 에러를 발생시킵니다.</li>\n      </ol>\n\n      <pre><code>function parent() {\n  const x = 10;\n  function child() {\n    console.log(x); // child에 없으므로 parent 스코프에서 x를 찾음 (스코프 체인)\n  }\n  child();\n}\nparent();</code></pre>\n\n      <h2>3. 스코프 체인의 원리</h2>\n      <p>스코프 체인은 <strong>Lexical Environment</strong>를 단방향으로 연결한 <strong>링크드리스트(Linked List)</strong> 구조입니다.</p>\n      \n      <h4>탐색 구조 시각화:</h4>\n      <pre style=\"background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 5px;\">\n[ Child Lexical Env ] ---Outer---> [ Parent Lexical Env ] ---Outer---> [ Global Lexical Env ]\n(현재 위치에서부터 위로(바깥쪽으로)만 탐색 가능)\n      </pre>\n\n      <h2>4. 어휘적 환경(Lexical Environment)과의 관계</h2>\n      <p>함수가 어디서 호출되었는지가 아니라, <strong>어디서 정의되었는지</strong>에 따라 상위 스코프가 결정됩니다. 이를 렉시컬 스코프(Lexical Scope)라고 하며, 실행 컨텍스트가 생성될 때 이 정보가 확정됩니다.</p>\n    "
}
